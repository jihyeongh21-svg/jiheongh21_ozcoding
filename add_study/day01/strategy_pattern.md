#  전략 패턴

## 1.  문제 상황 (SimUDuck)
* **상황**: 오리 시뮬레이션 게임 개발 중. 기존에는 `Duck` 슈퍼클래스를 통해 `swim()`과 `quack()`을 구현함.
* **요구사항 변경**: 오리가 날 수 있는 기능(`fly()`) 추가 요청.
* **1차 접근 (상속 사용)**:
    * `Duck` 클래스에 `fly()` 메서드 추가.
    * **문제점**: 날면 안 되는 '고무 오리(RubberDuck)'나 '가짜 오리'까지 상속을 통해 날게 되는 버그 발생.
    * **시사점**: 상속은 코드를 재사용하는 강력한 도구지만, 하위 클래스에 원치 않는 행동까지 강제할 수 있어 유연성이 떨어짐.

## 2. 문제해결 시도
 * **인터페이스 활용 시도**: `Flyable`, `Quackable` 인터페이스 정의.
* **문제점**: 인터페이스는 구현 코드를 가질 수 없으므로, 날 수 있는 모든 오리 클래스에 똑같은 비행 코드를 반복해서 작성해야 함.
* **결과**: 코드 중복이 발생하고, 비행 동작을 수정하려면 모든 클래스를 일일이 찾아가야 하므로 유지보수성이 낮음.

## 3. 핵심 디자인 원칙 적용

### (1) 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
* 오리 클래스에서 변하는 것(`fly`, `quack`)과 변하지 않는 것(기본 속성)을 분리.
* 변하는 행동을 `Duck` 클래스 외부에 별도의 클래스 집합으로 캡슐화함.

### (2) 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
* 상위 형식인 `FlyBehavior`, `QuackBehavior` 인터페이스를 정의.
* `Duck` 클래스는 구체적인 구현체(`FlyWithWings` 등)에 의존하지 않고, 인터페이스 변수만 참조함.
* **이점**: 실제 행동 구현 클래스는 `Duck` 클래스와 상관없이 언제든 추가하거나 변경할 수 있음.

### (3) 상속보다는 구성(Composition)을 활용한다.
* **구성(Composition)**: "A는 B를 가지고 있다" 관계.
* `Duck` 클래스가 행동 클래스(`Behavior`)를 내부 변수로 소유하는 방식.
* **이점**: 상속은 정적이지만, 구성은 동적으로 행동을 변경할 수 있음.

## 4. 결론: 전략 패턴 (Strategy Pattern)
* **정의**: 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있게 만든다.
* **핵심**: 전략 패턴을 활용하면 클라이언트(` Duck`)로 부터 알고리즘(`Behavior`)을 분리해서 독립적으로 변경 및 확장할 수 있다.

## 디자인 퍼즐

![alt text](image.png.webp)

**추상클래스**
Character

**추상 클래스를 상속받는 클래스** 
Queen,King,Knight,Troll

**인터페이스**
WeaponBehavior

**인터페이스 구현**
KnifeBehavior,BowAndArrowBehavior,AxeBhavior,SwordBevior

**무기설정 클래스**
무기설정 클래스 setWeapon()은 Character클래스에 추가
상속받는 다른 클래스에서 호출하여 무기(행위)교체가 가능



