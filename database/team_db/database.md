##  DB설계 실습

 1. 서비스 

 (**게임 아이템 wiki**)

    1.1 이용자가 아이템의 정보를 검색

    1.2 이용자 아이템을 장착한 상태의 정보를 조회

    1.3 이용자가 직점 아이템으 조합을 선택해서 정보를 조회

    1.4 조합한 아이템을 저장 및 조회

2. 테이블 및 컬럼

    2.1
    | 테이블명 (Table) | 역할 (Role) | 주요 컬럼 (Columns) |  
    | :--- | :--- | :--- |
    | **1. users** | **유저 기본 정보**<br>(캐릭터 순수 능력치) | `id`<br>`user_name`<br>`base_atk` |
    | **2. items** | **아이템 도감** | `item_id`<br>`item_name`<br>`item_atk` |
    | **3. sets** | **세트 효과 정의**| `set_id`<br>`set_name`<br>`set_effect` | 
    | **4. equip** | **실제 장착 상태** | `user_id`<br>`part`<br>`item_id` | `1` <br>`"WEAPON"`<br>`10` |
    | **5. wishlists** | **가상 시뮬레이션**<br>(임의 조합 저장) | `user_id`<br>`wishlist_name`<br>`whish_id` | 

3. DBMS와 트랜젝션(ACID), 무결성, 동시성제어(Concurrency Control)

    3.0 데이터 베이스
        데이버 베이스 종류
            관계형 vs 비관계형
                
                관계형 RDBMS : 데이터의 테이블(excel)형식으로 미리 정의된 스키마(데이터의구조)로 저장
                                테이블 끼리 서로 연결

                비관계형 NoSQL :  정해진 형식이 없이 데이터를 그대로 저장
        

            관계형 DB

            MySQL 

                1. 플러그인 스토리지 엔진 : 상황에 따라 엔진을 교체가 가능
                
                2. 오픈소스 : 무료

                3. 다양한 언어 지원 : C ,C++, Java, Python, PHP 등 다양한 언어를 지원

                4. 복제의 대중화 : 데이터를 다른 서버로 복사하눈 구성이 쉬움

                5. 트랜잭션 지원 : ACID 트랜잭션, MVCC, 행단위Lock을 지원

            Oracle

                1. 비싼비용

                2. RAC(Real Application Clusters) : 서버가 여러대 일 경우 한 대가 고장 날 경우 다른 서버가 즉시 이어받음
                                                    서버의 중단시간 0 초  
                3 PL/SQL : 표준 SQL 보다 훨씬 강력한 오라클만의 프로그래밍 언어를 내장 복잡학 로직을 구현이 가능

                4. 강력한 관리 기능 : 백업, 복구, 보안 기능이 정교하고 강력함

                5. 뛰어난 동시성 제어 지원 : 수만명의 동시 접속을 지원하면서 안정성 높음

            
            NoSQL
        
            Redis

            1. 인메모리 : 하드디스크가 아니라 RAM에 데이터를 저장 -> 빠른 속도

            2. key-value 구조 : 복잡한 테이블 없이 key로 데이터를 불러오는게 가능

            3. 다양한 자료구조 : 단순 string 말고도 list, set, 정렬된 set등을 저장이 가능

            4. 싱글 스레드 : 한 번에 하나의 명령만 처리 ->  lock없이 원자성을 보장

            5. 영속성 옵션(persistence): 메모리는 장치가 종료하면 날라가지만 옵션을 활성화 화면 하드디스크에 주기적 백업을 통해 보존이 가능

            MongoDB

            1. 스키마 리스 : 테이블의 정의가 필요가 없음

            2. BSON(Binary Json)포맷 ; JSON형태 그대로 저장이 가능 

            3. 샤딩(sharding)최적화 : 데이터가 많아지면 서버를 옆으로 늘리는 기능(scale-out)이 처음부터 내장되어 대용량 데이터 처리에 강점

            4. 다양한 인덱싱 : NoSQL임에도 위치 기반 검색 이나 텍스트 검색등 다양한 색인(index)기능을 제공
        



    3.1 트랜잭션
         트랜젝션이란 여러 쿼리를 하나로 묶은 논리적 최소 작업 단위

         ACID
            
             Atomicity 원자성 : 
                "All Or Nothing"  트랜잭션으로 묶인 모든 쿼리가 완료될 경유 커밋을 하고 아닌 경우에는 rollback을 한다.
 
             Consistancy 일관성 :
                 데이터베이스 내에 정해지 제약조건을 위한 하지안는다. 예를 들어 테이블의 특정 컬럼의 타입을 INT로 정의한 경우 해당 타입 외의 테이터를 삽입 할 수 없다.

             Isolation 고립성 : 
                서로 다른 트랜젝션은 서로의 작업에 영향을 끼쳐서는 안된다.  들 동시 DB에 여러 사용자가 접속해서 이용할 생기는 문제를 방지한다
            
             Durability 지속성 :
                한번 완료되면 데이베이스에 영구히 저장되어야 한다.
    
    3.2 무결성

    **데이터베이스의 데이터가 결함이 없고 정화하고 유효 상태**

         엔티티 무결성 : 모든 데이터는 식별 할 수 있는 고유한 식별자(PRIMARY KEY)를 가져야 한다.
                        (pk (기본키)는  null이 될 수 없음)
        
         참조 무결성  :  존재 하지 않는 데이터를 가리킬 수 없다. 외래키 (FORIGN KEY)는 부모 테이블의 존재하는 pk와 일치하거나 null이여야 한다

         도메인 무결성 : 데이터는 정해진 타입 , 제약조건, 길이를 지켜야 한다

         사용자 정의 무결성 : 사용자가 직접 정의한 규칙  (Triger나 제약 조건을 사용)
            Triger 특정 상황에 작동하는 SQL함수

    
    3.3 동시성 제어

    **고립성의 기술적 구현 방법**

        Lock 기반 동시성 제어 :
            데이터에 먼저 접근한 트랜젝션에 완료 될떄까지 다른 트랜젝션의 접근을 막음 
            
            종류
            공유 락(shared/read) : 조회는 허용 수정은 막음

            베타 락(Exclusive/Write) : 조회, 수정 둘다 막음
        
        MVCC(다중S버젼 동시성 제어) :
            데이터를 수정하는 중에 조회가 발생 할 경우 수정전 버젼의 데이터의 복사본을 조회

        낙관적/비관적 동시성 제어
            낙관적 동시성 제어 : 충돌이 일어나지 발생이 빈도가 낮을걸로 예상하고 수정 시에 데이터의 수정전의 조회한 데이터인지 확인

            비관적 동시성 제어 : 충돌이 빈번히 발생할거라고 예상하고 조회 시 부터 lock을 걸어 접근을 제한

        DeadLock 관리

            Deadlock: 둘 이상의 프로세스가 진행되 않고 서로 영원히 대기하는 교착상태

            발생조건

                1. 상호배제 Mutual exclusion
                    : 하나의 자원에 하나의 프로세스만이 사용가능한 경우 (상호배제)

                2.점유상태 Hold and wait
                    : 자원 하나를 가진채로 다른 자원을 기다리는 상활 (둘 이상의 자원이 필요한 상황에서 가진 자원 외의 자원을 받기 위해 대기상태) 

                3.선정불가 Non preemption
                    : 이미 선점된 자원을 가져 올 수 없어 계속 대기하는 경우
                
                4.순환성대기 Circle wait
                    : 꼬리를 물고 다른 프로세스끼리 해당 자원을 대기하는 상황
            
            해결방법

                1.예방
                    : 발생조건 중 하나라도 발생 하지 않게 미리 조치 

                2.회피
                    : 시스템에서 안정상태에서 안정상태로 자원을 할당
                        (교착에 빠지지 않는 상태를 안정상태 반대로 빠질 가능성이 있는 상태를 불안정상태)

                3.탐지
                    : 데드락의 발생을 가정하고 발생이 어디서 했는지 탐지하는 방식

                4.복구
                    : 말그대로 데드락을 복구( 크게 강제종료와 자원을 회수하는 두가지 방법)
        

    


    

        

            








